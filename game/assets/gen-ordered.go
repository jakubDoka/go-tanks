// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package assets

// StringBulletCapsule is component of ordered map that stores key and a value
type StringBulletCapsule struct {
	K string
	V Bullet
}

// StringBulletOrdered stores its items in underlying slice and map just keeps indexes
type StringBulletOrdered struct {
	m map[string]int
	s []StringBulletCapsule
}

// NOrderedMap initializes inner map
func NStringBulletOrdered() StringBulletOrdered {
	return StringBulletOrdered{
		m: map[string]int{},
	}
}

// IsNil reports whether StringBulletOrdered instance is uninitialized
func (o *StringBulletOrdered) IsNil() bool {
	return o.m == nil
}

// Bullet returns value under key
func (o *StringBulletOrdered) Bullet(key string) (val *Bullet, idx int, ok bool) {
	idx, k := o.m[key]
	if !k {
		return
	}
	return &o.s[idx].V, idx, true
}

// Put puts a value under key
func (o *StringBulletOrdered) Put(key string, value Bullet) {
	if i, ok := o.m[key]; ok {
		o.s[i].V = value
	} else {
		o.m[key] = len(o.s)
		o.s = append(o.s, StringBulletCapsule{key, value})
	}
}

// Remove removes the key value pair
func (o *StringBulletOrdered) Remove(key string) (v Bullet, i int, b bool) {
	val, idx, ok := o.Bullet(key)

	if ok {
		o.RemoveIndex(idx)
	} else {
		return
	}

	return *val, idx, ok
}

// RemoveIndex removes by index
func (o *StringBulletOrdered) RemoveIndex(idx int) (cell StringBulletCapsule) {
	cell = o.s[idx]
	delete(o.m, o.s[idx].K)
	o.shift(idx+1, len(o.s), -1)
	o.s = append(o.s[:idx], o.s[idx+1:]...)
	return
}

// Insert insets element under index and key
func (o *StringBulletOrdered) Insert(key string, idx int, value Bullet) {
	o.Remove(key)
	o.m[key] = idx
	o.shift(idx, len(o.s), 1)
	o.s = append(append(append(make([]StringBulletCapsule, 0, len(o.s)+1), o.s[:idx]...), StringBulletCapsule{key, value}), o.s[idx:]...)
}

// Slice returns underlying slice
func (o *StringBulletOrdered) Slice() []StringBulletCapsule {
	return o.s
}

// Index returns index of a key's value
func (o *StringBulletOrdered) Index(name string) (int, bool) {
	val, ok := o.m[name]
	return val, ok
}

// Clear removes all elements
func (o *StringBulletOrdered) Clear() {
	for k := range o.m {
		delete(o.m, k)
	}
	o.s = o.s[:0]
}

// ReIndex changes index of an element
func (o *StringBulletOrdered) ReIndex(old, new int) {
	if old == new {
		return // well
	}

	shifting := -1
	ol, n := old, new
	if old > new {
		shifting = 1
		old, new = new+1, old+1
	}

	cell := o.s[ol]
	o.shift(old-shifting, new-shifting, shifting)
	copy(o.s[old:new], o.s[old-shifting:new-shifting])
	o.m[cell.K] = n
	o.s[n] = cell
}

// Rename renames element and keeps index
func (o *StringBulletOrdered) Rename(old, new string) bool {
	val, ok := o.m[old]
	if ok {
		o.Remove(new)
		delete(o.m, old)
		o.m[new] = val
		o.s[val].K = new
		return true
	}
	return false
}

func (o *StringBulletOrdered) shift(start, end, dif int) {
	for i := start; i < end; i++ {
		o.m[o.s[i].K] += dif
	}
}

// StringTankCapsule is component of ordered map that stores key and a value
type StringTankCapsule struct {
	K string
	V Tank
}

// StringTankOrdered stores its items in underlying slice and map just keeps indexes
type StringTankOrdered struct {
	m map[string]int
	s []StringTankCapsule
}

// NOrderedMap initializes inner map
func NStringTankOrdered() StringTankOrdered {
	return StringTankOrdered{
		m: map[string]int{},
	}
}

// IsNil reports whether StringTankOrdered instance is uninitialized
func (o *StringTankOrdered) IsNil() bool {
	return o.m == nil
}

// Tank returns value under key
func (o *StringTankOrdered) Tank(key string) (val *Tank, idx int, ok bool) {
	idx, k := o.m[key]
	if !k {
		return
	}
	return &o.s[idx].V, idx, true
}

// Put puts a value under key
func (o *StringTankOrdered) Put(key string, value Tank) {
	if i, ok := o.m[key]; ok {
		o.s[i].V = value
	} else {
		o.m[key] = len(o.s)
		o.s = append(o.s, StringTankCapsule{key, value})
	}
}

// Remove removes the key value pair
func (o *StringTankOrdered) Remove(key string) (v Tank, i int, b bool) {
	val, idx, ok := o.Tank(key)

	if ok {
		o.RemoveIndex(idx)
	} else {
		return
	}

	return *val, idx, ok
}

// RemoveIndex removes by index
func (o *StringTankOrdered) RemoveIndex(idx int) (cell StringTankCapsule) {
	cell = o.s[idx]
	delete(o.m, o.s[idx].K)
	o.shift(idx+1, len(o.s), -1)
	o.s = append(o.s[:idx], o.s[idx+1:]...)
	return
}

// Insert insets element under index and key
func (o *StringTankOrdered) Insert(key string, idx int, value Tank) {
	o.Remove(key)
	o.m[key] = idx
	o.shift(idx, len(o.s), 1)
	o.s = append(append(append(make([]StringTankCapsule, 0, len(o.s)+1), o.s[:idx]...), StringTankCapsule{key, value}), o.s[idx:]...)
}

// Slice returns underlying slice
func (o *StringTankOrdered) Slice() []StringTankCapsule {
	return o.s
}

// Index returns index of a key's value
func (o *StringTankOrdered) Index(name string) (int, bool) {
	val, ok := o.m[name]
	return val, ok
}

// Clear removes all elements
func (o *StringTankOrdered) Clear() {
	for k := range o.m {
		delete(o.m, k)
	}
	o.s = o.s[:0]
}

// ReIndex changes index of an element
func (o *StringTankOrdered) ReIndex(old, new int) {
	if old == new {
		return // well
	}

	shifting := -1
	ol, n := old, new
	if old > new {
		shifting = 1
		old, new = new+1, old+1
	}

	cell := o.s[ol]
	o.shift(old-shifting, new-shifting, shifting)
	copy(o.s[old:new], o.s[old-shifting:new-shifting])
	o.m[cell.K] = n
	o.s[n] = cell
}

// Rename renames element and keeps index
func (o *StringTankOrdered) Rename(old, new string) bool {
	val, ok := o.m[old]
	if ok {
		o.Remove(new)
		delete(o.m, old)
		o.m[new] = val
		o.s[val].K = new
		return true
	}
	return false
}

func (o *StringTankOrdered) shift(start, end, dif int) {
	for i := start; i < end; i++ {
		o.m[o.s[i].K] += dif
	}
}

// StringWorldCapsule is component of ordered map that stores key and a value
type StringWorldCapsule struct {
	K string
	V World
}

// StringWorldOrdered stores its items in underlying slice and map just keeps indexes
type StringWorldOrdered struct {
	m map[string]int
	s []StringWorldCapsule
}

// NOrderedMap initializes inner map
func NStringWorldOrdered() StringWorldOrdered {
	return StringWorldOrdered{
		m: map[string]int{},
	}
}

// IsNil reports whether StringWorldOrdered instance is uninitialized
func (o *StringWorldOrdered) IsNil() bool {
	return o.m == nil
}

// World returns value under key
func (o *StringWorldOrdered) World(key string) (val *World, idx int, ok bool) {
	idx, k := o.m[key]
	if !k {
		return
	}
	return &o.s[idx].V, idx, true
}

// Put puts a value under key
func (o *StringWorldOrdered) Put(key string, value World) {
	if i, ok := o.m[key]; ok {
		o.s[i].V = value
	} else {
		o.m[key] = len(o.s)
		o.s = append(o.s, StringWorldCapsule{key, value})
	}
}

// Remove removes the key value pair
func (o *StringWorldOrdered) Remove(key string) (v World, i int, b bool) {
	val, idx, ok := o.World(key)

	if ok {
		o.RemoveIndex(idx)
	} else {
		return
	}

	return *val, idx, ok
}

// RemoveIndex removes by index
func (o *StringWorldOrdered) RemoveIndex(idx int) (cell StringWorldCapsule) {
	cell = o.s[idx]
	delete(o.m, o.s[idx].K)
	o.shift(idx+1, len(o.s), -1)
	o.s = append(o.s[:idx], o.s[idx+1:]...)
	return
}

// Insert insets element under index and key
func (o *StringWorldOrdered) Insert(key string, idx int, value World) {
	o.Remove(key)
	o.m[key] = idx
	o.shift(idx, len(o.s), 1)
	o.s = append(append(append(make([]StringWorldCapsule, 0, len(o.s)+1), o.s[:idx]...), StringWorldCapsule{key, value}), o.s[idx:]...)
}

// Slice returns underlying slice
func (o *StringWorldOrdered) Slice() []StringWorldCapsule {
	return o.s
}

// Index returns index of a key's value
func (o *StringWorldOrdered) Index(name string) (int, bool) {
	val, ok := o.m[name]
	return val, ok
}

// Clear removes all elements
func (o *StringWorldOrdered) Clear() {
	for k := range o.m {
		delete(o.m, k)
	}
	o.s = o.s[:0]
}

// ReIndex changes index of an element
func (o *StringWorldOrdered) ReIndex(old, new int) {
	if old == new {
		return // well
	}

	shifting := -1
	ol, n := old, new
	if old > new {
		shifting = 1
		old, new = new+1, old+1
	}

	cell := o.s[ol]
	o.shift(old-shifting, new-shifting, shifting)
	copy(o.s[old:new], o.s[old-shifting:new-shifting])
	o.m[cell.K] = n
	o.s[n] = cell
}

// Rename renames element and keeps index
func (o *StringWorldOrdered) Rename(old, new string) bool {
	val, ok := o.m[old]
	if ok {
		o.Remove(new)
		delete(o.m, old)
		o.m[new] = val
		o.s[val].K = new
		return true
	}
	return false
}

func (o *StringWorldOrdered) shift(start, end, dif int) {
	for i := start; i < end; i++ {
		o.m[o.s[i].K] += dif
	}
}
